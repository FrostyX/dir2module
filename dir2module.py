"""
Recursively read RPMs from DIR or read them from specified pkglist
and generate N:S:V:C:A.modulemd.yaml for them.
"""

import os
import fnmatch
import gi
import hawkey
from dnf.subject import Subject


gi.require_version("Modulemd", "2.0")
from gi.repository import Modulemd


def find_packages(path):
    """
    Recursively find RPM packages in a `path` and return their list
    """
    packages = []
    for _, __, filenames in os.walk(path):
        for filename in fnmatch.filter(filenames, "*.rpm"):
            if filename.endswith(".src.rpm"):
                continue
            packages.append(filename)
    return packages


def find_packages_in_file(path):
    """
    Parse a text file containing a list of packages and return their list
    """
    with open(path, "r") as pkglist:
        return [os.path.basename(pkg) for pkg in pkglist.read().split()]


def package_names(packages):
    """
    Takes a list of package filenames and returns a set of unique package names
    """
    names = set()
    for package in packages:
        subject = Subject(package.strip(".rpm"))
        nevras = subject.get_nevra_possibilities(forms=[hawkey.FORM_NEVRA])
        for nevra in nevras:
            names.add(nevra.name)
    return names


def package_nevras(packages):
    """
    Takes a list of package filenames and returns a set of unique NEVRAs
    """
    return {package2nevra(package) for package in packages}


def package2nevra(package):
    """
    Takes a package filename and returns its NEVRA
    """
    subject = Subject(package.strip(".rpm"))
    nevras = subject.get_nevra_possibilities(forms=[hawkey.FORM_NEVRA])
    for nevra in nevras:
        return "{N}-{E}:{V}-{R}.{A}".format(N=nevra.name, E=nevra.epoch or 0,
                                            V=nevra.version, R=nevra.release,
                                            A=nevra.arch)


def dumps_modulemd(name, stream, version, context, summary, arch, description,
                   licenses, packages):
    """
    Generate modulemd yaml based on input parameters and return it as a string
    """
    mod_stream = Modulemd.ModuleStreamV2.new(name, stream)
    mod_stream.set_version(version)
    mod_stream.set_summary(summary)
    mod_stream.set_description(description)

    mod_stream.add_module_license("MIT")
    for pkglicense in licenses:
        mod_stream.add_content_license(pkglicense)

    for package in package_names(packages):
        component = Modulemd.ComponentRpm.new(package)
        component.set_rationale("Present in the repository")
        mod_stream.add_component(component)
        mod_stream.add_rpm_api(package)

    for nevra in package_nevras(packages):
        mod_stream.add_rpm_artifact(nevra)

    index = Modulemd.ModuleIndex.new()
    index.add_module_stream(mod_stream)
    return index.dump_to_string()



def dump_modulemd(name, stream, version, context, arch, summary, description,
                  licenses, packages):
    """
    Generate modulemd yaml based on input parameters write it into file
    """

    filename = module_filename(name, stream, version, context, arch)
    yaml = dumps_modulemd(name, stream, version, context, arch, summary,
                          description, licenses, packages)
    with open(filename, "w") as moduleyaml:
        moduleyaml.write(yaml)


def module_filename(name, stream, version, context, arch):
    """
    Generate filename for a module yaml
    """
    return "{N}:{S}:{V}:{C}:{A}.modulemd.yaml".format(
        N=name, S=stream, V=version, C=context, A=arch)



def main():
    path = os.path.expanduser("~/rpmbuild/RPMS/")
    packages = find_packages(path)

    yaml = dumps_modulemd("foo", "bar", 123, "context", "x86_64",
                          "Summary and stuff",
                          "description should be autogenerated",
                          ["MIT"], packages)
    print(yaml)


if __name__ == "__main__":
    main()
